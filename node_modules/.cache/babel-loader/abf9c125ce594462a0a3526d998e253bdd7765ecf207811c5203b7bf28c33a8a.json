{"ast":null,"code":"export default function handleCpf(event) {\n  function formatarCPF(event) {\n    var campo = event.target;\n    var valor = campo.value.replace(/\\D/g, ''); // remove tudo que não é número\n    valor = valor.substring(0, 11); // limita a entrada a 11 dígitos\n    valor = valor.replace(/(\\d{3})(\\d)/, '$1.$2'); // coloca ponto depois dos 3 primeiros números\n    valor = valor.replace(/(\\d{3})(\\d)/, '$1.$2'); // coloca ponto depois dos 6 primeiros números\n    valor = valor.replace(/(\\d{3})(\\d{1,2})$/, '$1-$2'); // coloca hífen antes dos últimos 2 números\n    campo.value = valor; // atualiza o valor do campo com a máscara\n\n    // Verifica se o valor digitado é um CPF válido e adiciona ou remove a classe de erro\n    var valido = validarCPF(valor);\n    if (valido) {\n      campo.classList.remove('error');\n    } else {\n      campo.classList.add('error');\n    }\n  }\n  function validarCPF(cpf) {\n    cpf = cpf.replace(/[^\\d]+/g, ''); // remove tudo que não é número\n    if (cpf == '') return false; // se o CPF estiver vazio, é inválido\n\n    // Valida o primeiro dígito verificador do CPF\n    var soma = 0;\n    for (var i = 0; i < 9; i++) {\n      soma += parseInt(cpf.charAt(i)) * (10 - i);\n    }\n    var resto = 11 - soma % 11;\n    if (resto == 10 || resto == 11) {\n      resto = 0;\n    }\n    if (resto != parseInt(cpf.charAt(9))) {\n      return false;\n    }\n\n    // Valida o segundo dígito verificador do CPF\n    soma = 0;\n    for (var i = 0; i < 10; i++) {\n      soma += parseInt(cpf.charAt(i)) * (11 - i);\n    }\n    resto = 11 - soma % 11;\n    if (resto == 10 || resto == 11) {\n      resto = 0;\n    }\n    if (resto != parseInt(cpf.charAt(10))) {\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["handleCpf","event","formatarCPF","campo","target","valor","value","replace","substring","valido","validarCPF","classList","remove","add","cpf","soma","i","parseInt","charAt","resto"],"sources":["C:/.ssh/cadastroReact/cadastro/CadastroJovens/src/Utils/handleCPF.js"],"sourcesContent":["export default function handleCpf(event){\r\n    function formatarCPF(event) {\r\n        var campo = event.target;\r\n        var valor = campo.value.replace(/\\D/g, ''); // remove tudo que não é número\r\n        valor = valor.substring(0, 11); // limita a entrada a 11 dígitos\r\n        valor = valor.replace(/(\\d{3})(\\d)/, '$1.$2'); // coloca ponto depois dos 3 primeiros números\r\n        valor = valor.replace(/(\\d{3})(\\d)/, '$1.$2'); // coloca ponto depois dos 6 primeiros números\r\n        valor = valor.replace(/(\\d{3})(\\d{1,2})$/, '$1-$2'); // coloca hífen antes dos últimos 2 números\r\n        campo.value = valor; // atualiza o valor do campo com a máscara\r\n      \r\n        // Verifica se o valor digitado é um CPF válido e adiciona ou remove a classe de erro\r\n        var valido = validarCPF(valor);\r\n        if (valido) {\r\n          campo.classList.remove('error');\r\n        } else {\r\n          campo.classList.add('error');\r\n        }\r\n      }\r\n      \r\n      function validarCPF(cpf) {\r\n        cpf = cpf.replace(/[^\\d]+/g,''); // remove tudo que não é número\r\n        if (cpf == '') return false; // se o CPF estiver vazio, é inválido\r\n      \r\n        // Valida o primeiro dígito verificador do CPF\r\n        var soma = 0;\r\n        for (var i = 0; i < 9; i++) {\r\n          soma += parseInt(cpf.charAt(i)) * (10 - i);\r\n        }\r\n        var resto = 11 - (soma % 11);\r\n        if (resto == 10 || resto == 11) {\r\n          resto = 0;\r\n        }\r\n        if (resto != parseInt(cpf.charAt(9))) {\r\n          return false;\r\n        }\r\n      \r\n        // Valida o segundo dígito verificador do CPF\r\n        soma = 0;\r\n        for (var i = 0; i < 10; i++) {\r\n          soma += parseInt(cpf.charAt(i)) * (11 - i);\r\n        }\r\n        resto = 11 - (soma % 11);\r\n        if (resto == 10 || resto == 11) {\r\n          resto = 0;\r\n        }\r\n        if (resto != parseInt(cpf.charAt(10))) {\r\n          return false;\r\n        }\r\n      \r\n        return true;\r\n      }\r\n}"],"mappings":"AAAA,eAAe,SAASA,SAASA,CAACC,KAAK,EAAC;EACpC,SAASC,WAAWA,CAACD,KAAK,EAAE;IACxB,IAAIE,KAAK,GAAGF,KAAK,CAACG,MAAM;IACxB,IAAIC,KAAK,GAAGF,KAAK,CAACG,KAAK,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;IAC5CF,KAAK,GAAGA,KAAK,CAACG,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAChCH,KAAK,GAAGA,KAAK,CAACE,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC,CAAC;IAC/CF,KAAK,GAAGA,KAAK,CAACE,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC,CAAC;IAC/CF,KAAK,GAAGA,KAAK,CAACE,OAAO,CAAC,mBAAmB,EAAE,OAAO,CAAC,CAAC,CAAC;IACrDJ,KAAK,CAACG,KAAK,GAAGD,KAAK,CAAC,CAAC;;IAErB;IACA,IAAII,MAAM,GAAGC,UAAU,CAACL,KAAK,CAAC;IAC9B,IAAII,MAAM,EAAE;MACVN,KAAK,CAACQ,SAAS,CAACC,MAAM,CAAC,OAAO,CAAC;IACjC,CAAC,MAAM;MACLT,KAAK,CAACQ,SAAS,CAACE,GAAG,CAAC,OAAO,CAAC;IAC9B;EACF;EAEA,SAASH,UAAUA,CAACI,GAAG,EAAE;IACvBA,GAAG,GAAGA,GAAG,CAACP,OAAO,CAAC,SAAS,EAAC,EAAE,CAAC,CAAC,CAAC;IACjC,IAAIO,GAAG,IAAI,EAAE,EAAE,OAAO,KAAK,CAAC,CAAC;;IAE7B;IACA,IAAIC,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1BD,IAAI,IAAIE,QAAQ,CAACH,GAAG,CAACI,MAAM,CAACF,CAAC,CAAC,CAAC,IAAI,EAAE,GAAGA,CAAC,CAAC;IAC5C;IACA,IAAIG,KAAK,GAAG,EAAE,GAAIJ,IAAI,GAAG,EAAG;IAC5B,IAAII,KAAK,IAAI,EAAE,IAAIA,KAAK,IAAI,EAAE,EAAE;MAC9BA,KAAK,GAAG,CAAC;IACX;IACA,IAAIA,KAAK,IAAIF,QAAQ,CAACH,GAAG,CAACI,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;MACpC,OAAO,KAAK;IACd;;IAEA;IACAH,IAAI,GAAG,CAAC;IACR,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3BD,IAAI,IAAIE,QAAQ,CAACH,GAAG,CAACI,MAAM,CAACF,CAAC,CAAC,CAAC,IAAI,EAAE,GAAGA,CAAC,CAAC;IAC5C;IACAG,KAAK,GAAG,EAAE,GAAIJ,IAAI,GAAG,EAAG;IACxB,IAAII,KAAK,IAAI,EAAE,IAAIA,KAAK,IAAI,EAAE,EAAE;MAC9BA,KAAK,GAAG,CAAC;IACX;IACA,IAAIA,KAAK,IAAIF,QAAQ,CAACH,GAAG,CAACI,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE;MACrC,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}